---
layout:     post
title:      "Muduo学习笔记"
subtitle:   "多线程网络库"
date:       2018-03-24 10:00:00
author:     "AJW"
header-img: "img/tech.jpg"
tags:
    - 计算机网络
    - C++
    - 服务器
---

很想了解服务器端的一些知识，但nginx这种代码让我直接来看估计是受不了的，而且是C。

muduo是陈硕编写的一款开源C++网络库，据说性能以及实现上都不错，而且有配套书《Linux多线程服务端编程：使用muduo C++网络库》，正好结合看一下源码，涨涨计算机网络和服务器端的姿势。

## Reactor

Reactor是广泛应用于服务器中的一种设计模式，它是一种事件驱动模型，常见结构如下

![reactor](\img\in-post\muduo\reactor.png)

其中Reactor只负责处理新的连接，并将它注册到一个\<fd, EventHandler\>的map中。它同时持有一个EventDemultiplexer，EventDemultiplexer通过epoll来监听fd，发现有读写后，就会调用对应的EventHandler来处理事件。

具体的逻辑可以看一下的例子，感觉会更清晰一点。

**Logging Server接收连接**

![reactor example](\img\in-post\muduo\reactor_example1.png)

1. Logging Server注册LoggingAcceptor到InitiationDispatcher。

2. Logging Server调用InitiationDispatcher的handle_events()方法启动。

3. InitiationDispatcher内部调用select()方法（Synchronous Event Demultiplexer），阻塞等待Client连接。

4. Client连接到Logging Server。

5. InitiationDisptcher中的select()方法返回，并通知LoggingAcceptor有新的连接到来。 

6. LoggingAcceptor调用accept方法accept这个新连接。

7. LoggingAcceptor创建新的LoggingHandler。

8. 新的LoggingHandler注册到InitiationDispatcher中(同时也注册到Synchonous Event Demultiplexer中)，等待Client发起写log请求。

   ​

   **Client向Logging Server写Log**
   ![reactor example2](\img\in-post\muduo\reactor_example2.png)

9. Client发送log到Logging server。

10. InitiationDispatcher监测到相应的Handle中有事件发生，返回阻塞等待，根据返回的Handle找到LoggingHandler，并回调LoggingHandler中的handle_event()方法。

11. LoggingHandler中的handle_event()方法中读取Handle中的log信息。

12. 将接收到的log写入到日志文件、数据库等设备中。
    3.4步骤循环直到当前日志处理完成。

13. 返回到InitiationDispatcher等待下一次日志写请求。



要注意到，一开始我们是需要把服务器的fd先注册进去的，因为我们也要监听连接的到来。而服务器的EventHandler里就是注册新连接的过程。



## Muduo的基本思想

Muduo的一个重要的思想是**one loop per thread**，这里的loop其实可以看作是一个reactor（代码中是EventLoop）。这种方案的特点是有一个main Reactor负责accept新的连接（Acceptor），然后把连接挂在某个sub Reactor中。muduo采用的是固定大小的一个Reactor Pool，在服务器开启时初始化。

![one loop per thread](\img\in-post\muduo\one_loop_per_thread.PNG)

## 一些关键类的分析

### EventLoop

EventLoop可以看作就是一个Reactor，根据one loop per thread的原则，EventLoop在构造时，会检查当前线程是否已经创建了其他的EventLoop对象。

```C++
__thread EventLoop* t_loopInThisThread = 0; //__thread关键字保证每个线程有一个t_loopInThisThread
```

EventLoop的构造函数会检查t_loopInThisThread的值，如果已经被赋值了，那么说明该线程已经有一个EventLoop对象了，会报错，否则就把该值置为this指针。